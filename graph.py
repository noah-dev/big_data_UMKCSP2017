#SUPER ROUGH CODE - NOT FOR SUBMISSION
#!/usr/bin/env python

#Import libraries for generating figure. the use('Agg') is set because
#archlinux is unable to display plots via terminal.
import matplotlib
matplotlib.use('Agg')

import matplotlib.pyplot as plt
from matplotlib import gridspec

fig_width = 12
fig_height = 8

#makeFig is called by app.py - responsible for generating and saving figure
#q is used to decide which query to run.
#result is a list of values generated by a query that will be graphed.
#nameSave is a filename used to save the figure
#fig_title is the title to be used for the figure
#time_stamp is a string of the time at which the query was started
#does not return anything
def makeFig(q, result, nameSave, fig_attrib, time_stamp):
    #Each query needs to be graphed a bit differently
    if q == 1:
        pyplotfig = graph_t1(q, result, fig_attrib, time_stamp)
    elif q == 2:
        pyplotfig = graph_t2(q,result, fig_attrib, time_stamp)
    elif q == 3:
        pyplotfig = graph_t3(q,result, fig_attrib, time_stamp)
    #Save graph
    saveGraph(q, pyplotfig, nameSave)

#First value in result is a scalar correlation Factor
#Second value in result is a list of two values, for pie chart
def graph_t1(q, result, fig_attrib, time_stamp):
    correlation = result[0]
    pie = result[1]
    fig_title, axis, fig_title_scale, axis_scale, fig_desc = fig_attrib
    fig_timestamp = 'Began query at: ' + time_stamp

    plt.figure(1,figsize=(12,8))
    gs = gridspec.GridSpec(1, 3, width_ratios=[3, 1, 1])

    plt.subplot(gs[0])
    labels = axis
    labels[0] = labels[0] + ': ' + "{:.2e}".format(pie[0])
    labels[1] = labels[1] + ': ' + "{:.2e}".format(pie[1])

    plt.pie(pie, labels=labels, autopct = '%1.0f%%', shadow=True)
    plt.axis('equal')
    plt.title(fig_title +'\n\n')

    plt.subplot(gs[2])
    plt.bar(0,correlation)
    plt.ylim(-1,1)
    plt.xticks([0],[axis_scale])
    plt.title(fig_timestamp + '\n\n' + fig_title_scale)
    plt.figtext(.1,0.01,fig_desc)

    return plt


def graph_t2(q, result, fig_attrib, time_stamp):
    x=[1,2,3]
    fig_title, axis, fig_desc = fig_attrib
	
	#Append the raw count to the axis labels.
	#Shows how much volume each category has
    for i in range(len(axis)):
        axis[i] = axis[i] + '\n' + "{:.2e}".format(result[i])
    #Create figure and configure it
    plt.figure(2,figsize=(fig_width,fig_height))
    plt.xticks(x,axis)
    plt.bar(x,result)
    fig_timestamp = 'Began query at: ' + time_stamp +'\n'
    plt.title(fig_title + '\nLog Scale', loc='left')
    plt.title(fig_timestamp, loc='right')
    plt.yscale('log')
    plt.grid(True,which="both")
    plt.figtext(.1,0.01,fig_desc)
    return plt

def graph_t3(q, result, fig_attrib, time_stamp):
    time = result[0]
    trend = result[1]

    main_val = []
    main_axis = []
    for pair in time:
        main_axis.append(pair[0])
        main_val.append(float(pair[1]))

    x = range(len(time))

    #Retrive name of trends
    trend1 = trend[0][0]
    for row in trend:
        if row[0] != trend1:
            trend2 = row[0]
            break
    for row in trend:
        if row[0] != trend1 and row[0] != trend2:
            trend3 = row[0]
            break

    #Create plots for the three trends. If their time stamp does not
    #appear in the main list, place a zero:
    trend1_val = [0]*len(time)
    trend2_val = [0]*len(time)
    trend3_val = [0]*len(time)
    for row in trend:
        if row[0] == trend1 and row[1] in main_axis:
            idx = main_axis.index(row[1])
            trend1_val[idx] = float(row[2])
        elif row[0] == trend2 and row[1] in main_axis:
            idx = main_axis.index(row[1])
            trend2_val[idx] = float(row[2])
        elif row[0] == trend3 and row[1] in main_axis:
            idx = main_axis.index(row[1])
            trend3_val[idx] = float(row[2])


    legend = ['Across all trends',trend1, trend2, trend3]
    fig_title, fig_desc = fig_attrib
    #Create figure and configure it
    plt.figure(3,figsize=(12,8))
    plt.plot(x,main_val)
    plt.plot(x,trend1_val)
    plt.plot(x,trend2_val)
    plt.plot(x,trend3_val)

    plt.tick_params(axis = 'x', which = 'minor', bottom = 'off', top = 'off', labelbottom = 'off' )
    fig_timestamp = 'Began query at: ' + time_stamp
    plt.title(fig_title + '\nStart: ' + main_axis[0] +'\nEnd: '+ main_axis[-1], loc='left')
    plt.title(fig_timestamp + '\n\n', loc='right')
    plt.figtext(.1,0.01,fig_desc)
    plt.legend(legend)
    plt.grid()
    return plt

#saveGraph is called by makeFig.py - responsible for saving figure
#q is used to decide which query to run.
#pyplotfig is a pyplot object, holding the figure
#nameSave is used to name the figure
#does not return anything
def saveGraph(q, pyplotfig, nameSave):
    pyplotfig.savefig(nameSave, bbox_inches='tight')
    pyplotfig.clf()
